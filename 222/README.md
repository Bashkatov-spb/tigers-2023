## Установка на Ubuntu Linux:

> https://docs.docker.com/engine/install/ubuntu/

## Docker:

Это платформа для разработки, доставки и запуска контейнерных приложений. Docker позволяет создавать контейнеры, автоматизировать их запуск и развертывание, управляет жизненным циклом. Он позволяет запускать множество контейнеров на одной хост-машине.

## Контейнер:

Это способ упаковать приложение и все его зависимости в единый образ. Этот образ запускается в изолированной среде, не влияющей на основную операционную систему. Контейнеры позволяют отделить приложение от инфраструктуры: разработчикам не нужно задумываться, в каком окружении будет работать их приложение, будут ли там нужные настройки и зависимости. Они просто создают приложение, упаковывают все зависимости и настройки в единый образ. Затем этот образ можно запускать на других системах, не беспокоясь, что приложение не запустится.

## Docker Image (образ):

Это неизменяемый файл (образ), из которого разворачиваются контейнеры. Приложения упаковываются именно в образы, из которых потом уже создаются контейнеры.

## Dockerfile:

Это инструкция для сборки образа. Это простой текстовый файл с названием `Dockerfile`, содержащий по одной команде в каждой строке. В нем указываются все программы, зависимости и образы, которые нужны для разворачивания образа.

## .dockerignore:

Файл `.dockerignore` является инструментом, который может использоваться для уточнения контекста сборки Docker. Используя этот файл, можно задать правила исключения файлов из контекста сборки, а значит уменьшить время, необходимое на сборку tar-архива и отправку его на сервер.

## Docker Registry:

Это репозиторий с Docker-образами. Разработчики создают образы своих программ и выкладывают их в репозиторий, чтобы их можно было скачать и воспользоваться ими. Распространенный публичный репозиторий — Docker Hub. В нем собраны образы множества популярных программ или платформ: базы данных, веб — серверы, компиляторы, операционные системы и так далее. Также можно создать свой приватный репозиторий (Docker Registry), например внутри компании. Разработчики будут размещать там образы, которые будут использоваться всей компанией.

## Docker, как решение проблем:

Контейнеры позволяют упаковать в единый образ приложение и все его зависимости: библиотеки, системные утилиты и файлы настройки. Это упрощает перенос приложения на другую инфраструктуру.

Например, разработчики создают приложение в системе разработки, там все настроено и приложение работает. Когда приложение готово, его нужно перенести в систему тестирования и затем в продуктивную среду. И если в этих системах будет не хватать какой-нибудь зависимости, то приложение не будет работать. В этом случае программистам придется отвлечься от разработки и совместно с командой поддержки разбираться в ситуации. Контейнеры позволяют избежать такой проблемы, потому что они содержат в себе все необходимое для запуска приложения. Программисты смогут сосредоточиться на разработке, а не решении инфраструктурных проблем.

## Пример использования Docker для запуска (развёртывания) контейнера с Node (изначально образ проверяется локально):

> sudo docker run --name <container_name> -p <external_port>:<inner_port> <image>
> документация о возможности запуска без sudo: https://docs.docker.com/engine/install/linux-postinstall/

## Основные команды:

- `docker` — базовая команда с описанием всех команд и документации
- `docker version` — определение текущей версии Docker
- `docker login` — авторизация в DockerHub

---

- `docker images` — текущие образы Docker
- `docker image prune` — удалить все неиспользуемые образы
- `docker image inspect <image_id>` — детальная информация об образе

---

- `docker run <image_id>` — запуск Docker образа через ID, консоль будет занята запущенным контейнером
- `docker run -i <image_id>` — запуск Docker контейнера в интерактивном режиме по ID (выйти из режима `.exit`)
- `docker run --name <container_name> -p <external_port>:<inner_port> <image>` — запуск Docker контейнера c указанным именем, и установленным внешним и внутренним портом, на основе указанного образа
- `docker run --name <container_name> -d -rm -p <external_port>:<inner_port> <image>` — запуск Docker контейнера c указанным именем и последующим его удалением после его остановки, с указанным внешним и внутренним портом на основе указанного образа

---

- `docker start <container_id>` — запуск Docker контейнера через ID в фоновом режиме, аналог атрибута `-d, --detach`
- `docker stop <container_id>` — остановка Docker контейнера через ID

---

- `docker push <repository>` — залить образ в DockerHub, где название образа/репозитория должно соотвествовать схеме: `<docker_hub_username>/<repository>`
- `docker pull <image_name>` — подтягивание контейнера из Docker Hub (если не указываем версию, подтянется последняя)

---

- `docker ps` — список всех запущенных контейнеров
- `docker ps -a` — список всех контейнеров
- `docker tag <old_image_name> <new_image_name>` — переименовать образ (создаст копию с новым именем)

---

- `docker rm <container_id>` — удалить контейнер по ID
- `docker rmi <image_id>` — удалить образ по ID
- `docker container prune` — удалить все остановленные контейнеры

---

- `docker attach <container_id>` — переход в терминал запущенного контейнера
- `docker logs <container_id>` — логирование контейнера

---

- `docker build .` — базовая сборка образа
- `docker build -t <my_image> .` — дать название собираемому образу
- `docker build -t <my_image>:<version> .` — дать название собираемому образу + установка версии

## Создание образа для запуска в контейнере:

1. Создать в рабочей папке файл: `Dockerfile`
2. Определить на основе какого образа будет построен наш образ (в нашем случае Node): `FROM node`
3. Хорошим тоном создать внутри образа рабочую папку, куда в дальнейшем будем копировать все необходимые файлы: `WORKDIR /application`
4. Для предотвращения копирования лишних файлов или папок создаём файл: `.dockerignore` в котром описываем игнорируемое (node_modules, .git и так далее)
5. Так как образ имеет свою файловую систему, её необходимо наполнить файлами (после создания образа его уже не изменить, только создавать новый), `COPY . .`, где точки указывают корень исходной рабочей папки и корень образа (если есть `WORKDIR`, то копирование будет в указанную папку)
6. Установить необходимые пакеты в образе `RUN npm ci`, запускается только при построении образа
7. Установить порт для нашего приложения `EXPOSE 3000`
8. Описать способ запуска приложения в образе, `CMD ["node", "app.js"]`, запускается каждый раз при запуске образа
9. Выполнить команду `docker build -t <docker-hub-username>/<image-title> .`, для сборки образа, зафиксировать его ID
10. Проверить созданный образ `docker images` по ID
11. Разворачиваем контейнер на основе нового образа `docker run --name <container_name> <image>`
12. Для остановки запущенного контейнера используем команду `docker stop <container_id>`
13. Назначение внешнего и внутреннего порта (мапинг) для приложения: `docker run --name <container_name> -p <external_port>:<inner_port> <image>`
14. Для фонового запуска контейнера используем ключ `-d`, `docker run --name <container_name> -d -p <external_port>:<inner_port> <image>`
15. При необходимости внести изменения в образ нужно его пересоздавать, есть оптимальный способ ускорить его создание используя кэширование, сначала `COPY package.json /application` и `COPY package-lock.json /application`, после `RUN npm ci` и только после этого добавить основное копирование `COPY . .`
16. Если есть необходимость в переменных окружения, то описать её можно так: `ENV PORT 3000`, так же меняется и команда оперделения порта `EXPOSE $PORT`
17. Для загрузки образа на DockerHub необходимо авторизоваться с помощью команды `docker login`
18. Сама загрузка образа/репозитория инициируется командой `docker push <repository>`, где название образа/репозитория должно соотвествовать схеме: `<docker-hub-username>/<repository>`

## Этапы развёртывая/деплоя Docker образа на Heroku:

1. Логин на Heroku, через `heroku-cli`
2. Создать приложение внутри сервиса Heroku
3. Создать БД Postgres внутри сервиса Heroku и связать с нужным приложением
4. Подготовить когфигурацию БД в режиме `production`, пример:

```js
{
  "development": {
    "use_env_variable": "DATABASE_URL"
  },
  "production": {
    "use_env_variable": "DATABASE_URL",
    "dialectOptions": {"ssl": { "rejectUnauthorized": false }}
  }
}
```

5. Выбрать метод развёртывания
6. Подготовить скрипты запуска приложения в `package.json`
7. Подготовить `Dockerfile` и `.dockerignore`
8. В `Dockerfile` явно указать переменную окружения: `ENV NODE_ENV production`
9. Подготовить образ с определённым именем: `docker build -t registry.heroku.com/<heroku_app_id>/web .`,
10. Авторизироваться в реестр контейнеров Heroku командой: `heroku container:login`
11. После формирования образа/репозитория его необходимо залить в хранилище образов Heroku, через команду: `docker push registry.heroku.com/<heroku_app_id>/web:latest`
12. Зарелизить загруженный образ/репозиторий можно используя команду: `heroku container:release web --app <heroku_app_id>`

## Этапы развёртывая/деплоя Docker образов на VDS Selectel:

- Docker образ для БД
  - Переходим на https://vds.selectel.ru
  - Создаём аккаунт если его нет либо авторизируемся
  - Создаём сервер с предустановленным Docker
  - Создаём SSH-ключ для подключения к серверу (на Windows удобно делать SSH-ключ и подключение через `PuTTY`)
  - Проверяем наличие Docker на сервере командой: `docker -v`
  - Скачиваем Docker образ PostgreSQL c помощью команды: `docker pull postgres`
  - Запуск контейнера PostgreSQL с помощью команды (пользователь: postgres, пароль: postgres, имя БД: postgres-db): `docker run --name postgres-container -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=postgres-db -p 5432:5432 postgres`
  - Далее стоит настроить Docker Volumes используя команду для создания тома `pgdata`: `docker volume create pgdata`
  - После нужно пересобрать контейнер с использованием Docker Volumes: `docker run --name postgres-container -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=postgres-db -p 5432:5432 -v pgdata:/var/lib/postgresql/data postgres`
  - При необходимости удаления тома `pgdata` используйте команду: `docker volume rm pgdata`
  - При необходимости удаления контейнера используйте команду: `docker rm <container_name_or_id>`
- Docker образ для сервера (при http сервере настройка конфигурации БД: `"dialectOptions": {}`, при https: `"dialectOptions": {"ssl": { "rejectUnauthorized": false }}`)
  - Создать в рабочей папке файл: `Dockerfile`
  - Определить на основе какого образа будет построен наш образ (в нашем случае Node): `FROM node`
  - В `Dockerfile` явно указать переменные окружения: `ENV NODE_ENV production` и `ENV DATABASE_URL <postgres-url>`
  - Хорошим тоном создать внутри образа рабочую папку, куда в дальнейшем будем копировать все необходимые файлы: `WORKDIR /application`
  - Для предотвращения копирования лишних файлов или папок создаём файл: `.dockerignore` в котром описываем игнорируемое (`node_modules`, `.git`)
  - Так как образ имеет свою файловую систему, её необходимо наполнить файлами (после создания образа его уже не изменить, только создавать новый), `COPY . .`, где точки указывают корень исходной рабочей папки и корень образа (если есть `WORKDIR`, то копирование будет в указанную папку)
  - Установить необходимые пакеты в образе командой: `RUN npm ci`, запускается только при построении образа
  - Установить внутренний порт для нашего приложения: `EXPOSE 3000`
  - Описать способ запуска приложения в образе, `CMD ['node', 'app.js']`, запускается каждый раз при запуске образа
  - Выполнить команду `docker build -t <docker-hub-username>/<image-title> .`, для сборки образа, `<docker-hub-username>` используется для загрузки образа в DockerHub
  - Проверить созданный образ: `docker images`
  - Для загрузки образа на DockerHub необходимо авторизоваться с помощью команды: `docker login`
  - Сама загрузка образа/репозитория инициируется командой: `docker push <repository>`, где название образа/репозитория должно соотвествовать схеме: `<docker-hub-username>/<repository>`
  - После загрузки подключаемся через SSH к VDS и подтягиваем образ с DockerHub командой: `docker pull <docker-hub-username>/<repository>`
  - Разворачиваем контейнер на основе нового образа с мапингом портов: `docker run --name <container-name> -p 80:3000 <image-name>`
  - Для остановки запущенного контейнера используем команду: `docker stop <container-id>`
